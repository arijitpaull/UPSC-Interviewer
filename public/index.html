<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UPSC Interview Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: radial-gradient(circle at center, #101010 0%, #000000 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #interviewButton {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: #eaefff;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: box-shadow 0.3s ease;
            position: relative;
            box-shadow: 0 0 40px rgba(234, 239, 255, 0.3);
            transform-origin: center;
        }

        #interviewButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 60px rgba(234, 239, 255, 0.5);
        }

        #interviewButton:active {
            transform: scale(0.98);
        }

        #interviewButton span {
            color: #101010;
            font-size: 13px;
            font-weight: 400;
            letter-spacing: 0.5px;
            transition: opacity 0.3s ease;
            text-align: center;
        }

        #interviewButton.paused {
            background: #666666;
        }

        #interviewButton.paused span {
            color: #ffffff;
        }

        .fade-out {
            opacity: 0 !important;
        }

        #statusText {
            position: absolute;
            bottom: 80px;
            color: #eaefff;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
            max-width: 80%;
        }

        #statusText.visible {
            opacity: 0.7;
        }

        #endButton {
            position: absolute;
            top: 40px;
            right: 40px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid #333333;
            color: #888888;
            border-radius: 0;
            cursor: pointer;
            font-size: 11px;
            font-weight: 400;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #endButton.visible {
            opacity: 1;
            pointer-events: all;
        }

        #endButton:hover {
            background: transparent;
            border-color: #666666;
            color: #ffffff;
        }

        #stopButton {
            position: absolute;
            top: 40px;
            right: 200px;
            padding: 10px 20px;
            background: transparent;
            border: 1px solid #333333;
            color: #888888;
            border-radius: 0;
            cursor: pointer;
            font-size: 11px;
            font-weight: 400;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #stopButton.visible {
            opacity: 1;
            pointer-events: all;
        }

        #stopButton:hover {
            background: transparent;
            border-color: #ff6666;
            color: #ff6666;
        }

        /* Snackbar for errors */
        #snackbar {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #333333;
            color: #ffffff;
            padding: 16px 24px;
            border-radius: 4px;
            font-size: 14px;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.3s ease;
            pointer-events: none;
            max-width: 400px;
            z-index: 2000;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        #snackbar.visible {
            opacity: 1;
            transform: translateY(0);
        }

        #snackbar.error {
            background: #d32f2f;
        }

        #snackbar.warning {
            background: #f57c00;
        }

        #snackbar.info {
            background: #1976d2;
        }

        @media (max-width: 768px) {
            #interviewButton {
                width: 160px;
                height: 160px;
            }

            #interviewButton span {
                font-size: 12px;
            }

            #endButton {
                top: 20px;
                right: 20px;
                padding: 8px 16px;
                font-size: 10px;
            }

            #stopButton {
                top: 20px;
                right: 165px;
                padding: 8px 16px;
                font-size: 10px;
            }

            #statusText {
                font-size: 13px;
                bottom: 60px;
            }

            #snackbar {
                bottom: 20px;
                right: 20px;
                max-width: calc(100% - 40px);
            }
        }

        @media (max-width: 480px) {
            #interviewButton {
                width: 140px;
                height: 140px;
            }

            #interviewButton span {
                font-size: 11px;
            }

            #stopButton {
                top: 20px;
                right: auto;
                left: 20px;
                padding: 8px 12px;
                font-size: 9px;
            }

            #endButton {
                top: 20px;
                right: 20px;
                padding: 8px 12px;
                font-size: 9px;
            }
        }

        /* Metrics Overlay Styles - Minimal Monochrome */
        #metricsOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.97);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow-y: auto;
            padding: 20px;
        }

        #metricsOverlay.visible {
            opacity: 1;
        }

        .metrics-modal {
            max-width: 800px;
            margin: 0 auto;
            background: #000000;
            border: 1px solid #333333;
        }

        .metrics-header {
            padding: 40px 40px 20px;
            border-bottom: 1px solid #222222;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metrics-header h2 {
            color: #ffffff;
            font-size: 18px;
            font-weight: 400;
            margin: 0;
            letter-spacing: 1px;
            text-transform: uppercase;
        }

        .close-metrics {
            background: none;
            border: 1px solid #333333;
            color: #888888;
            font-size: 20px;
            width: 32px;
            height: 32px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 300;
        }

        .close-metrics:hover {
            border-color: #666666;
            color: #ffffff;
        }

        .metrics-content {
            padding: 30px 40px;
        }

        .metrics-section {
            margin-bottom: 40px;
            padding-bottom: 30px;
            border-bottom: 1px solid #1a1a1a;
        }

        .metrics-section:last-child {
            border-bottom: none;
        }

        .metrics-section h3 {
            color: #ffffff;
            font-size: 12px;
            font-weight: 400;
            margin-bottom: 20px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .scores-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .score-card {
            background: #0a0a0a;
            padding: 20px;
            border: 1px solid #1a1a1a;
            text-align: left;
        }

        .score-label {
            color: #666666;
            font-size: 10px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .score-value {
            color: #ffffff;
            font-size: 28px;
            font-weight: 300;
            margin-bottom: 12px;
            font-family: 'Courier New', monospace;
        }

        .score-bar {
            height: 2px;
            background: #1a1a1a;
            overflow: hidden;
        }

        .score-fill {
            height: 100%;
            background: #ffffff;
            transition: width 0.8s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: #0a0a0a;
            padding: 15px 20px;
            border: 1px solid #1a1a1a;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-label {
            color: #666666;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .stat-value {
            color: #ffffff;
            font-size: 16px;
            font-weight: 300;
            font-family: 'Courier New', monospace;
        }

        .stat-value.warning {
            color: #888888;
        }

        .strengths-list, .improvements-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
        }

        .strength-item, .improvement-item {
            background: #0a0a0a;
            padding: 15px 20px;
            margin-bottom: 10px;
            border-left: 2px solid #333333;
            color: #cccccc;
            font-size: 13px;
            line-height: 1.6;
            font-weight: 300;
        }

        .strength-item {
            border-left-color: #ffffff;
        }

        .improvement-item {
            border-left-color: #666666;
        }

        .detailed-feedback {
            margin-top: 15px;
        }

        .feedback-item {
            background: #0a0a0a;
            padding: 20px;
            margin-bottom: 15px;
            border: 1px solid #1a1a1a;
        }

        .feedback-item h4 {
            color: #ffffff;
            font-size: 11px;
            font-weight: 400;
            margin: 0 0 12px 0;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .feedback-item p {
            color: #999999;
            font-size: 13px;
            line-height: 1.7;
            margin: 0;
            font-weight: 300;
        }

        .overall-feedback {
            background: #0a0a0a;
            padding: 25px;
            border: 1px solid #1a1a1a;
            color: #cccccc;
            font-size: 13px;
            line-height: 1.8;
            margin-top: 15px;
            font-weight: 300;
        }

        .metrics-footer {
            padding: 30px 40px;
            border-top: 1px solid #222222;
            display: flex;
            justify-content: center;
        }

        .btn-primary {
            background: #ffffff;
            color: #000000;
            border: none;
            padding: 12px 30px;
            font-size: 11px;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn-primary:hover {
            background: #dddddd;
        }

        @media (max-width: 768px) {
            .metrics-modal {
                margin: 0;
            }

            .metrics-header {
                padding: 30px 20px 15px;
            }

            .metrics-header h2 {
                font-size: 14px;
            }

            .metrics-content {
                padding: 20px;
            }

            .scores-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <button id="interviewButton">
            <span>Begin Interview</span>
        </button>
        <div id="statusText"></div>
        <button id="stopButton">Stop</button>
        <button id="endButton">End Interview</button>
    </div>

    <div id="snackbar"></div>

    <script>
        const API_BASE = window.location.hostname === 'localhost' 
            ? 'http://localhost:3000' 
            : window.location.origin;
        const SYSTEM_PROMPT_BASE = `You are a Senior UPSC Interview Board Member at Dholpur House conducting Tanya Singh's personality test interview.

YOUR ROLE: You are the INTERVIEWER asking questions. Tanya is the CANDIDATE answering.

YOUR PERSONALITY:
- Formal, calm, slightly strict, authoritative
- Retired IAS officer, age 55-62
- Ask short, sharp, probing questions
- Use follow-ups when answers are vague
- Switch topics quickly to test adaptability
- Never flatter or encourage
- Test depth of understanding, not memorization

YOU ALREADY KNOW FROM HER DAF (don't ask these):
- Name: Tanya Singh
- Age: 23 years old
- From: New Ashok Nagar, East Delhi
- Education: B.A. Economics (Hons), SRCC, University of Delhi (8.77 CGPA)
- Optional: Economics
- Family: Single parent household, father deceased
- Top Service Choice: Indian Foreign Service (IFS)
- Achievements: MUN Best Delegate (Global Debt), Pink Tax debate prize, Founded ARTIBUS platform, Mental health campaign organizer
- Hobbies: Absurdist literature, volunteering with children, cue sports (pool)

WHAT TO ASK HER ABOUT:

1. ASPIRATIONS & MOTIVATION
- Why civil services?
- Why IFS specifically? (her #1 choice)
- What draws her to diplomacy?
- If she doesn't get IFS, will IAS be equally motivating?
- How does Economics optional help in foreign service?

2. INTERNATIONAL RELATIONS (IFS focus)
- Russia-Ukraine war and India's position
- Israel-Palestine conflict
- Indo-Pacific strategy
- India-China border issues
- Neighbourhood first policy
- Global South leadership
- Multilateralism and UNSC reform
- Diaspora diplomacy

3. ECONOMICS (her optional)
- Global debt vulnerabilities (her MUN topic)
- Inflation, unemployment in India
- Fiscal federalism
- Women's labour force participation
- Pink tax and gender economics
- Direct vs indirect taxation
- India's economic challenges

4. CURRENT AFFAIRS & POLICY
- Mental health (she organized campaign)
- Education for underserved (she volunteers)
- Delhi governance issues
- Social media regulation
- Gender equality measures
- Youth unemployment

5. LITERATURE & PHILOSOPHY (her hobby)
- Absurdist literature - what appeals to her?
- Dystopian themes - relevance to governance?
- Ethical questions from literature
- Philosophy and administration

6. SITUATIONAL/ADMINISTRATIVE
- As DM of East Delhi, how would you...?
- As MEA officer, India's stand on...?
- Handling protests, misinformation, crises
- Policy implementation challenges

7. FOLLOW-UPS
When she gives vague/general answers:
- "Be more specific."
- "That sounds generic. What's YOUR view?"
- "How exactly would you implement that?"
- "You mentioned X - justify that claim."
- "Don't you think there's a contradiction here?"

CRITICAL RULES:
- Ask ONE question at a time (1-2 sentences max)
- Questions should be substantive, not personal details
- Challenge vague answers immediately
- Switch domains to test breadth
- No praise, no validation
- Keep UPSC formal tone always

EXAMPLES OF GOOD QUESTIONS:
✅ "Why IFS over IAS?"
✅ "What's India's position on the Russia-Ukraine war?"
✅ "How does pink tax impact women's economic participation?"
✅ "You founded ARTIBUS - how does public speaking help in administration?"
✅ "What appeals to you about absurdist literature?"
✅ "As DM, how would you address education gaps in East Delhi?"

EXAMPLES OF BAD QUESTIONS (don't ask these):
❌ "What's your name?"
❌ "Tell me about your family background."
❌ "What's your roll number?"
❌ "Where are you from?"
❌ "What did you study?"

You already know all that from her DAF. Ask about IDEAS, OPINIONS, POLICIES, CURRENT AFFAIRS.`;

        // ============ STATE MANAGEMENT ============
        const AppState = {
            interview: {
                active: false,
                paused: false,
                sessionId: null,
                interests: [],
                conversationHistory: []
            },
            audio: {
                context: null,
                currentPlayback: null,
                currentAbortController: null,
                mediaRecorder: null,
                analyser: null,
                chunks: [],
                visualizationFrameId: null
            },
            speech: {
                isSpeaking: false,
                isProcessing: false,
                interruptionDetected: false
            },
            ui: {
                button: null,
                buttonText: null,
                statusText: null,
                endButton: null,
                stopButton: null,
                snackbar: null
            }
        };

        // ============ ERROR HANDLING & NOTIFICATIONS ============
        function showSnackbar(message, type = 'info') {
            const snackbar = AppState.ui.snackbar;
            snackbar.textContent = message;
            snackbar.className = `visible ${type}`;
            
            setTimeout(() => {
                snackbar.classList.remove('visible');
            }, type === 'error' ? 5000 : 3000);
        }

        function handleError(error, context) {
            console.error(`Error in ${context}:`, error);
            
            // Network errors
            if (!navigator.onLine) {
                showSnackbar('No internet connection. Please try again later.', 'error');
                return;
            }
            
            // API errors
            if (error.message.includes('API') || error.message.includes('fetch')) {
                showSnackbar('Server error. Please try again later.', 'error');
                return;
            }
            
            // Microphone errors
            if (error.name && (error.name.includes('NotAllowed') || error.name.includes('Permission'))) {
                showSnackbar('Microphone access denied. Please allow and reload.', 'error');
                return;
            }
            
            // Generic error
            showSnackbar('An error occurred. Please try again later.', 'error');
        }

        // ============ INITIALIZATION ============
        function initializeApp() {
            // Get UI elements
            AppState.ui.button = document.getElementById('interviewButton');
            AppState.ui.buttonText = AppState.ui.button.querySelector('span');
            AppState.ui.statusText = document.getElementById('statusText');
            AppState.ui.endButton = document.getElementById('endButton');
            AppState.ui.stopButton = document.getElementById('stopButton');
            AppState.ui.snackbar = document.getElementById('snackbar');

            // Initialize audio context
            AppState.audio.context = new (window.AudioContext || window.webkitAudioContext)();

            // Event listeners
            AppState.ui.button.addEventListener('click', handleButtonClick);
            AppState.ui.endButton.addEventListener('click', endInterview);
            AppState.ui.stopButton.addEventListener('click', stopInterview);

            // Resume audio context on user interaction
            document.addEventListener('click', () => {
                if (AppState.audio.context.state === 'suspended') {
                    AppState.audio.context.resume();
                }
            }, { once: true });

            // Online/offline detection
            window.addEventListener('online', () => showSnackbar('Connection restored', 'info'));
            window.addEventListener('offline', () => showSnackbar('No internet connection', 'warning'));
        }

        // ============ BUTTON CLICK HANDLER ============
        function handleButtonClick() {
            if (!AppState.interview.active) {
                startInterview();
            } else if (AppState.interview.paused) {
                resumeInterview();
            } else {
                pauseInterview();
            }
        }

        // ============ PAUSE/RESUME FUNCTIONALITY ============
        function pauseInterview() {
            if (!AppState.interview.active || AppState.interview.paused) return;
            
            AppState.interview.paused = true;
            AppState.ui.button.classList.add('paused');
            AppState.ui.buttonText.textContent = 'Resume';
            AppState.ui.buttonText.style.display = 'block';
            AppState.ui.buttonText.classList.remove('fade-out');
            
            // Stop current audio playback
            if (AppState.audio.currentPlayback) {
                AppState.audio.currentPlayback.pause();
                if (AppState.audio.visualizationFrameId) {
                    cancelAnimationFrame(AppState.audio.visualizationFrameId);
                }
                AppState.ui.button.style.transform = 'scale(1)';
            }
            
            // Stop microphone recording
            if (AppState.audio.mediaRecorder && AppState.audio.mediaRecorder.state === 'recording') {
                AppState.audio.mediaRecorder.stop();
            }
            
            updateStatus('Interview paused');
            showSnackbar('Interview paused', 'info');
        }

        function resumeInterview() {
            if (!AppState.interview.active || !AppState.interview.paused) return;
            
            AppState.interview.paused = false;
            AppState.ui.button.classList.remove('paused');
            AppState.ui.buttonText.classList.add('fade-out');
            
            setTimeout(() => {
                AppState.ui.buttonText.style.display = 'none';
            }, 300);
            
            updateStatus('Resuming interview...');
            showSnackbar('Interview resumed', 'info');
            
            // Resume listening
            setTimeout(() => {
                if (!AppState.speech.isProcessing) {
                    startContinuousListening();
                }
            }, 500);
        }

        // ============ START INTERVIEW ============
        async function startInterview() {
            try {
                // Check microphone permission first
                const testStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                testStream.getTracks().forEach(track => track.stop());
                
                // Initialize session
                const sessionResponse = await fetch('https://upsc-interviewer-ahna.vercel.app/api/session/init', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (!sessionResponse.ok) throw new Error('Session init failed');
                
                const sessionData = await sessionResponse.json();
                AppState.interview.sessionId = sessionData.sessionId;
                AppState.interview.interests = sessionData.interests;
                AppState.interview.active = true;
                AppState.interview.conversationHistory = [];
                
                // Update UI
                AppState.ui.buttonText.classList.add('fade-out');
                setTimeout(() => {
                    AppState.ui.buttonText.style.display = 'none';
                }, 300);
                AppState.ui.endButton.classList.add('visible');
                AppState.ui.stopButton.classList.add('visible');
                
                // Start interview
                updateStatus('Interviewer is speaking...');
                await speakText("Good morning, Tanya. Please introduce yourself.");
                
                setTimeout(() => startContinuousListening(), 300);
                
            } catch (error) {
                handleError(error, 'startInterview');
                resetUI();
            }
        }

        // ============ END INTERVIEW ============
        async function endInterview() {
            if (!AppState.interview.active) return;
            
            AppState.interview.active = false;
            AppState.interview.paused = false;
            
            // Disable both buttons immediately to prevent double-clicks
            AppState.ui.endButton.disabled = true;
            AppState.ui.stopButton.disabled = true;
            AppState.ui.endButton.style.opacity = '0.5';
            AppState.ui.stopButton.style.opacity = '0.5';
            AppState.ui.endButton.style.cursor = 'not-allowed';
            AppState.ui.stopButton.style.cursor = 'not-allowed';
            
            // Stop everything immediately
            stopAllAudioAndRecording();
            
            updateStatus('Generating performance report...');
            
            try {
                const reportResponse = await fetch(API_BASE + '/api/session/report', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: AppState.interview.sessionId,
                        conversationHistory: AppState.interview.conversationHistory
                    })
                });
                
                if (!reportResponse.ok) throw new Error('Report generation failed');
                
                const report = await reportResponse.json();
                displayMetricsReport(report);
                
            } catch (error) {
                handleError(error, 'endInterview');
                // Re-enable buttons on error
                AppState.ui.endButton.disabled = false;
                AppState.ui.stopButton.disabled = false;
                AppState.ui.endButton.style.opacity = '1';
                AppState.ui.stopButton.style.opacity = '1';
                AppState.ui.endButton.style.cursor = 'pointer';
                AppState.ui.stopButton.style.cursor = 'pointer';
            }
            
            resetUI();
        }

        // ============ STOP INTERVIEW (NO METRICS) ============
        function stopInterview() {
            if (!AppState.interview.active) return;
            
            AppState.interview.active = false;
            AppState.interview.paused = false;
            
            // Disable both buttons immediately to prevent double-clicks
            AppState.ui.endButton.disabled = true;
            AppState.ui.stopButton.disabled = true;
            AppState.ui.endButton.style.opacity = '0.5';
            AppState.ui.stopButton.style.opacity = '0.5';
            AppState.ui.endButton.style.cursor = 'not-allowed';
            AppState.ui.stopButton.style.cursor = 'not-allowed';
            
            // Stop everything immediatelyy
            stopAllAudioAndRecording();
            
            // Delete session data (no metrics needed)
            if (AppState.interview.sessionId) {
                fetch(API_BASE + '/api/session/delete', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ sessionId: AppState.interview.sessionId })
                }).catch(e => console.error('Session deletion failed:', e));
            }
            
            // Reset everything
            AppState.interview.sessionId = null;
            AppState.interview.interests = [];
            AppState.interview.conversationHistory = [];
            
            resetUI();
            showSnackbar('Interview stopped', 'info');
        }

        // ============ STOP ALL AUDIO & RECORDING ============
        function stopAllAudioAndRecording() {
            // Abort ongoing TTS request
            if (AppState.audio.currentAbortController) {
                AppState.audio.currentAbortController.abort();
                AppState.audio.currentAbortController = null;
            }
            
            // Stop current audio
            if (AppState.audio.currentPlayback) {
                AppState.audio.currentPlayback.pause();
                AppState.audio.currentPlayback = null;
            }
            
            // Stop recording
            if (AppState.audio.mediaRecorder && AppState.audio.mediaRecorder.state === 'recording') {
                AppState.audio.mediaRecorder.stop();
            }
            
            // Stop visualization
            if (AppState.audio.visualizationFrameId) {
                cancelAnimationFrame(AppState.audio.visualizationFrameId);
            }
            
            // Reset speech state
            AppState.speech.isSpeaking = false;
            AppState.speech.isProcessing = false;
            AppState.speech.interruptionDetected = false;
            
            // Reset button visual
            AppState.ui.button.classList.remove('active', 'speaking', 'paused');
            AppState.ui.button.style.transform = 'scale(1)';
        }

        // ============ TEXT-TO-SPEECH ============
        async function speakText(text) {
            if (AppState.interview.paused) return;
            
            try {
                AppState.ui.button.classList.add('speaking');
                
                // Create AbortController for this TTS request so we can cancel it
                const abortController = new AbortController();
                AppState.audio.currentAbortController = abortController;
                
                const response = await fetch(API_BASE + '/api/tts', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text }),
                    signal: abortController.signal // Allow cancellation
                });

                if (!response.ok) throw new Error('TTS failed');

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                
                // Set playback speed to make speech faster
                // 1.0 = normal speed, 1.15 = 15% faster (natural but quicker)
                audio.playbackRate = 1.15;
                
                AppState.audio.currentPlayback = audio;

                const source = AppState.audio.context.createMediaElementSource(audio);
                const analyserNode = AppState.audio.context.createAnalyser();
                analyserNode.fftSize = 256;
                
                source.connect(analyserNode);
                analyserNode.connect(AppState.audio.context.destination);
                
                visualizeAudio(analyserNode);

                return new Promise((resolve, reject) => {
                    audio.onended = () => {
                        cleanup();
                        resolve();
                    };
                    
                    audio.onerror = () => {
                        cleanup();
                        reject(new Error('Audio playback failed'));
                    };
                    
                    audio.onpause = () => {
                        if (AppState.interview.paused || AppState.speech.interruptionDetected) {
                            cleanup();
                            resolve();
                        }
                    };
                    
                    audio.play().catch(err => {
                        cleanup();
                        reject(err);
                    });
                    
                    function cleanup() {
                        if (AppState.audio.visualizationFrameId) {
                            cancelAnimationFrame(AppState.audio.visualizationFrameId);
                        }
                        AppState.ui.button.classList.remove('speaking');
                        AppState.ui.button.style.transform = 'scale(1)';
                        URL.revokeObjectURL(audioUrl);
                        AppState.audio.currentPlayback = null;
                        AppState.audio.currentAbortController = null;
                    }
                });
            } catch (error) {
                // If aborted due to interruption, that's expected - don't log as error
                if (error.name === 'AbortError') {
                    console.log('TTS request aborted (interrupted by user)');
                } else {
                    console.error('TTS Error:', error);
                    handleError(error, 'speakText');
                }
                AppState.ui.button.classList.remove('speaking');
                AppState.ui.button.style.transform = 'scale(1)';
                AppState.audio.currentPlayback = null;
                AppState.audio.currentAbortController = null;
                throw error;
            }
        }

        // ============ AUDIO VISUALIZATION ============
        function visualizeAudio(analyserNode) {
            const bufferLength = analyserNode.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            let currentScale = 1;
            const smoothingFactor = 0.15; // Smoother transitions

            function animate() {
                if (!AppState.audio.currentPlayback || AppState.audio.currentPlayback.paused || AppState.audio.currentPlayback.ended) {
                    // Smooth return to scale 1
                    if (currentScale > 1.01) {
                        currentScale += (1 - currentScale) * 0.2;
                        AppState.ui.button.style.transform = `scale(${currentScale})`;
                        AppState.audio.visualizationFrameId = requestAnimationFrame(animate);
                    } else {
                        AppState.ui.button.style.transform = 'scale(1)';
                    }
                    return;
                }

                analyserNode.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;
                
                // More evident scaling (0.6 instead of 0.25) with smoother easing
                const targetScale = 1 + (average / 255) * 0.6;
                
                // Smooth interpolation between current and target
                currentScale += (targetScale - currentScale) * smoothingFactor;
                
                AppState.ui.button.style.transform = `scale(${currentScale})`;
                AppState.ui.button.style.transition = 'transform 0.05s ease-out';
                
                AppState.audio.visualizationFrameId = requestAnimationFrame(animate);
            }

            animate();
        }

        // ============ CONTINUOUS LISTENING ============
        async function startContinuousListening() {
            if (!AppState.interview.active || AppState.speech.isProcessing || AppState.interview.paused) return;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                const source = AppState.audio.context.createMediaStreamSource(stream);
                const micAnalyser = AppState.audio.context.createAnalyser();
                micAnalyser.fftSize = 256;
                source.connect(micAnalyser);
                
                AppState.audio.analyser = micAnalyser;
                AppState.audio.mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' });
                AppState.audio.chunks = [];

                AppState.audio.mediaRecorder.ondataavailable = (event) => {
                    AppState.audio.chunks.push(event.data);
                };

                AppState.audio.mediaRecorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    
                    if (AppState.audio.visualizationFrameId) {
                        cancelAnimationFrame(AppState.audio.visualizationFrameId);
                    }
                    AppState.ui.button.classList.remove('active');
                    AppState.ui.button.style.transform = 'scale(1)';

                    if (!AppState.interview.active || AppState.interview.paused) return;

                    const audioBlob = new Blob(AppState.audio.chunks, { type: 'audio/webm' });
                    await processUserSpeech(audioBlob);
                };

                updateStatus('Listening...');
                AppState.ui.button.classList.add('active');
                AppState.audio.mediaRecorder.start();
                
                detectSpeechAndPauses(micAnalyser);

            } catch (error) {
                handleError(error, 'startContinuousListening');
                resetUI();
            }
        }

        // ============ SPEECH DETECTION ============
        function detectSpeechAndPauses(analyser) {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const speechThreshold = 30;
            let consecutiveSilenceFrames = 0;
            const silenceFramesNeeded = 75; // ~1.25s at 60fps
            let currentScale = 1;
            const smoothingFactor = 0.2; // Smooth transitions for user speech

            function checkAudioLevel() {
                if (!AppState.interview.active || !AppState.audio.mediaRecorder || 
                    AppState.audio.mediaRecorder.state !== 'recording' || AppState.interview.paused) {
                    return;
                }

                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;

                if (average > speechThreshold) {
                    consecutiveSilenceFrames = 0;
                    
                    if (!AppState.speech.isSpeaking) {
                        AppState.speech.isSpeaking = true;
                        
                        // Interruption detection - abort ongoing TTS request
                        if (AppState.audio.currentPlayback && !AppState.audio.currentPlayback.paused) {
                            console.log('User interrupted interviewer - stopping audio');
                            AppState.speech.interruptionDetected = true;
                            
                            // Abort the fetch request if still in progress
                            if (AppState.audio.currentAbortController) {
                                AppState.audio.currentAbortController.abort();
                            }
                            
                            // Stop current audio playback
                            AppState.audio.currentPlayback.pause();
                            AppState.audio.currentPlayback = null;
                            AppState.ui.button.classList.remove('speaking');
                        }
                    }
                    
                    // More evident scaling (0.5 instead of 0.3) with smooth easing
                    const targetScale = 1 + (average / 255) * 0.5;
                    currentScale += (targetScale - currentScale) * smoothingFactor;
                    AppState.ui.button.style.transform = `scale(${currentScale})`;
                    AppState.ui.button.style.transition = 'transform 0.05s ease-out';
                } else {
                    consecutiveSilenceFrames++;
                    
                    // Smooth return to scale 1
                    currentScale += (1 - currentScale) * 0.15;
                    AppState.ui.button.style.transform = `scale(${currentScale})`;
                    
                    if (AppState.speech.isSpeaking && consecutiveSilenceFrames >= silenceFramesNeeded) {
                        AppState.speech.isSpeaking = false;
                        if (AppState.audio.mediaRecorder && AppState.audio.mediaRecorder.state === 'recording') {
                            AppState.audio.mediaRecorder.stop();
                        }
                        return;
                    }
                }

                AppState.audio.visualizationFrameId = requestAnimationFrame(checkAudioLevel);
            }

            checkAudioLevel();
        }

        // ============ PROCESS USER SPEECH ============
        async function processUserSpeech(audioBlob) {
            if (AppState.speech.isProcessing) return;
            AppState.speech.isProcessing = true;

            try {
                const formData = new FormData();
                formData.append('audio', audioBlob, 'audio.webm');

                const transcriptionResponse = await fetch(API_BASE + '/api/stt', {
                    method: 'POST',
                    body: formData,
                    signal: AbortSignal.timeout(15000)
                });

                if (!transcriptionResponse.ok) throw new Error('Transcription failed');

                const transcription = await transcriptionResponse.json();
                const userText = transcription.text;

                if (!userText || userText.trim().length === 0) {
                    updateStatus('No speech detected. Please continue...');
                    AppState.speech.isProcessing = false;
                    setTimeout(() => startContinuousListening(), 1000);
                    return;
                }

                // Track metrics
                if (AppState.interview.sessionId) {
                    fetch(API_BASE + '/api/session/track', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            sessionId: AppState.interview.sessionId,
                            metrics: {},
                            interruptionDetected: AppState.speech.interruptionDetected
                        })
                    }).catch(e => console.error('Tracking failed:', e));
                }

                AppState.interview.conversationHistory.push({
                    role: 'user',
                    content: userText
                });

                updateStatus('Interviewer is thinking...');
                const interviewerResponse = await getInterviewerResponse();

                AppState.interview.conversationHistory.push({
                    role: 'assistant',
                    content: interviewerResponse
                });

                updateStatus('Interviewer is speaking...');
                await speakText(interviewerResponse);

                AppState.speech.isProcessing = false;
                AppState.speech.interruptionDetected = false;
                
                setTimeout(() => startContinuousListening(), 300);

            } catch (error) {
                handleError(error, 'processUserSpeech');
                AppState.speech.isProcessing = false;
                setTimeout(() => startContinuousListening(), 2000);
            }
        }

        // ============ GET INTERVIEWER RESPONSE ============
        async function getInterviewerResponse() {
            try {
                const systemPrompt = SYSTEM_PROMPT_BASE.replace(
                    '{INTERESTS}',
                    `- ${AppState.interview.interests[0]}\n- ${AppState.interview.interests[1]}`
                );

                const messages = [
                    { role: 'system', content: systemPrompt },
                    ...AppState.interview.conversationHistory
                ];

                const response = await fetch(API_BASE + '/api/chat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        messages,
                        sessionId: AppState.interview.sessionId 
                    }),
                    signal: AbortSignal.timeout(15000)
                });

                if (!response.ok) throw new Error('Chat API failed');

                const data = await response.json();
                return data.choices[0].message.content;

            } catch (error) {
                handleError(error, 'getInterviewerResponse');
                return "I apologize, there was a technical issue. Could you please repeat that?";
            }
        }

        // ============ METRICS DISPLAY ============
        function displayMetricsReport(report) {
            const { analysis, rawMetrics } = report;
            
            const overlay = document.createElement('div');
            overlay.id = 'metricsOverlay';
            overlay.innerHTML = `
                <div class="metrics-modal">
                    <div class="metrics-header">
                        <h2>Performance Report</h2>
                        <button class="close-metrics" onclick="hideMetricsReport()">×</button>
                    </div>
                    
                    <div class="metrics-content">
                        <div class="metrics-section">
                            <h3>Scores</h3>
                            <div class="scores-grid">
                                ${Object.entries(analysis.scores).map(([key, data]) => `
                                    <div class="score-card">
                                        <div class="score-label">${key}</div>
                                        <div class="score-value">${data.score}/10</div>
                                        <div class="score-bar">
                                            <div class="score-fill" style="width: ${data.score * 10}%"></div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="metrics-section">
                            <h3>Session Data</h3>
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <span class="stat-label">Responses</span>
                                    <span class="stat-value">${rawMetrics.totalResponses}</span>
                                </div>
                            </div>
                        </div>
                        
                        ${analysis.strengths && analysis.strengths.length > 0 ? `
                        <div class="metrics-section">
                            <h3>Strengths</h3>
                            <ul class="strengths-list">
                                ${analysis.strengths.map(s => `<li class="strength-item">${s}</li>`).join('')}
                            </ul>
                        </div>
                        ` : ''}
                        
                        <div class="metrics-section">
                            <h3>Critical Areas for Improvement</h3>
                            <ul class="improvements-list">
                                ${analysis.improvements.map(i => `<li class="improvement-item">${i}</li>`).join('')}
                            </ul>
                        </div>
                        
                        <div class="metrics-section">
                            <h3>Detailed Feedback</h3>
                            <div class="detailed-feedback">
                                ${Object.entries(analysis.scores).map(([key, data]) => `
                                    <div class="feedback-item">
                                        <h4>${key.charAt(0).toUpperCase() + key.slice(1)}</h4>
                                        <p>${data.feedback}</p>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        <div class="metrics-section">
                            <h3>Overall Assessment</h3>
                            <p class="overall-feedback">${analysis.overall}</p>
                        </div>
                    </div>
                    
                    <div class="metrics-footer">
                        <button class="btn-primary" onclick="hideMetricsReport()">Start New Interview</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            setTimeout(() => overlay.classList.add('visible'), 100);
        }

        function hideMetricsReport() {
            const overlay = document.getElementById('metricsOverlay');
            if (overlay) {
                overlay.classList.remove('visible');
                setTimeout(() => overlay.remove(), 300);
            }
        }

        // ============ UI HELPERS ============
        function updateStatus(text) {
            AppState.ui.statusText.textContent = text;
            AppState.ui.statusText.classList.add('visible');
        }

        function resetUI() {
            AppState.ui.button.classList.remove('active', 'speaking', 'paused');
            AppState.ui.button.style.transform = 'scale(1)';
            AppState.ui.buttonText.style.display = 'block';
            AppState.ui.buttonText.textContent = 'Begin Interview';
            AppState.ui.buttonText.classList.remove('fade-out');
            AppState.ui.statusText.classList.remove('visible');
            AppState.ui.endButton.classList.remove('visible');
            AppState.ui.stopButton.classList.remove('visible');
            
            // Re-enable buttons
            AppState.ui.endButton.disabled = false;
            AppState.ui.stopButton.disabled = false;
            AppState.ui.endButton.style.opacity = '1';
            AppState.ui.stopButton.style.opacity = '1';
            AppState.ui.endButton.style.cursor = 'pointer';
            AppState.ui.stopButton.style.cursor = 'pointer';
        }

        // ============ INITIALIZE ON LOAD ============
        window.addEventListener('DOMContentLoaded', initializeApp);
    </script>
</body>
</html>