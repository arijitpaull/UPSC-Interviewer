<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UPSC Interview Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: radial-gradient(circle at center, #101010 0%, #000000 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #container {
            position: relative;
            width: 100%;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #interviewButton {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: #eaefff;
            border: none;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: all 0.3s ease;
            position: relative;
            box-shadow: 0 0 40px rgba(234, 239, 255, 0.3);
        }

        #interviewButton:hover {
            transform: scale(1.05);
            box-shadow: 0 0 60px rgba(234, 239, 255, 0.5);
        }

        #interviewButton:active {
            transform: scale(0.98);
        }

        #interviewButton span {
            color: #101010;
            font-size: 18px;
            font-weight: 600;
            letter-spacing: 0.5px;
            transition: opacity 0.3s ease;
        }

        #interviewButton.active {
            animation: pulse 1s ease-in-out infinite;
        }

        #interviewButton.speaking {
            animation: speaking 0.3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px rgba(234, 239, 255, 0.3);
            }
            50% {
                transform: scale(1.1);
                box-shadow: 0 0 80px rgba(234, 239, 255, 0.6);
            }
        }

        @keyframes speaking {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.15);
            }
        }

        .fade-out {
            opacity: 0 !important;
        }

        #statusText {
            position: absolute;
            bottom: 80px;
            color: #eaefff;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
            max-width: 80%;
        }

        #statusText.visible {
            opacity: 0.7;
        }

        #endButton {
            position: absolute;
            top: 40px;
            right: 40px;
            padding: 12px 24px;
            background: rgba(234, 239, 255, 0.1);
            border: 1px solid rgba(234, 239, 255, 0.3);
            color: #eaefff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            opacity: 0;
            transition: all 0.3s ease;
            pointer-events: none;
        }

        #endButton.visible {
            opacity: 1;
            pointer-events: all;
        }

        #endButton:hover {
            background: rgba(234, 239, 255, 0.2);
            border-color: rgba(234, 239, 255, 0.5);
        }

        .error-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(255, 100, 100, 0.1);
            border: 1px solid rgba(255, 100, 100, 0.3);
            color: #ffaaaa;
            padding: 20px 30px;
            border-radius: 12px;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            max-width: 80%;
            text-align: center;
        }

        .error-message.visible {
            opacity: 1;
        }

        @media (max-width: 768px) {
            #interviewButton {
                width: 160px;
                height: 160px;
            }

            #interviewButton span {
                font-size: 16px;
            }

            #endButton {
                top: 20px;
                right: 20px;
                padding: 10px 20px;
                font-size: 13px;
            }

            #statusText {
                font-size: 13px;
                bottom: 60px;
            }
        }

        @media (max-width: 480px) {
            #interviewButton {
                width: 140px;
                height: 140px;
            }

            #interviewButton span {
                font-size: 14px;
            }
        }

        /* Metrics Overlay Styles */
        #metricsOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s ease;
            overflow-y: auto;
            padding: 20px;
        }

        #metricsOverlay.visible {
            opacity: 1;
        }

        .metrics-modal {
            max-width: 900px;
            margin: 0 auto;
            background: linear-gradient(135deg, #1a1a1a 0%, #0a0a0a 100%);
            border-radius: 16px;
            border: 1px solid rgba(234, 239, 255, 0.1);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .metrics-header {
            padding: 30px;
            border-bottom: 1px solid rgba(234, 239, 255, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .metrics-header h2 {
            color: #eaefff;
            font-size: 28px;
            margin: 0;
        }

        .close-metrics {
            background: rgba(234, 239, 255, 0.1);
            border: none;
            color: #eaefff;
            font-size: 32px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .close-metrics:hover {
            background: rgba(234, 239, 255, 0.2);
            transform: rotate(90deg);
        }

        .metrics-content {
            padding: 30px;
        }

        .metrics-section {
            margin-bottom: 30px;
        }

        .metrics-section h3 {
            color: #eaefff;
            font-size: 20px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(234, 239, 255, 0.2);
        }

        .scores-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .score-card {
            background: rgba(234, 239, 255, 0.05);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(234, 239, 255, 0.1);
            text-align: center;
        }

        .score-label {
            color: rgba(234, 239, 255, 0.7);
            font-size: 14px;
            margin-bottom: 10px;
        }

        .score-value {
            color: #eaefff;
            font-size: 32px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .score-bar {
            height: 6px;
            background: rgba(234, 239, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .score-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a9eff 0%, #7b68ee 100%);
            transition: width 0.5s ease;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }

        .stat-item {
            background: rgba(234, 239, 255, 0.05);
            padding: 15px;
            border-radius: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .stat-label {
            color: rgba(234, 239, 255, 0.7);
            font-size: 14px;
        }

        .stat-value {
            color: #eaefff;
            font-size: 20px;
            font-weight: 600;
        }

        .stat-value.warning {
            color: #ffaa00;
        }

        .strengths-list, .improvements-list {
            list-style: none;
            padding: 0;
            margin: 15px 0;
        }

        .strength-item, .improvement-item {
            background: rgba(234, 239, 255, 0.05);
            padding: 12px 20px;
            margin-bottom: 10px;
            border-radius: 8px;
            color: #eaefff;
            font-size: 15px;
            line-height: 1.6;
        }

        .strength-item {
            border-left: 3px solid #4a9eff;
        }

        .improvement-item {
            border-left: 3px solid #ffaa00;
        }

        .detailed-feedback {
            margin-top: 15px;
        }

        .feedback-item {
            background: rgba(234, 239, 255, 0.05);
            padding: 15px 20px;
            margin-bottom: 15px;
            border-radius: 8px;
            border-left: 3px solid rgba(234, 239, 255, 0.3);
        }

        .feedback-item h4 {
            color: #eaefff;
            font-size: 16px;
            margin: 0 0 10px 0;
        }

        .feedback-item p {
            color: rgba(234, 239, 255, 0.8);
            font-size: 14px;
            line-height: 1.6;
            margin: 0;
        }

        .overall-feedback {
            background: rgba(234, 239, 255, 0.08);
            padding: 20px;
            border-radius: 8px;
            color: #eaefff;
            font-size: 15px;
            line-height: 1.8;
            margin-top: 15px;
            border: 1px solid rgba(234, 239, 255, 0.15);
        }

        .metrics-footer {
            padding: 20px 30px;
            border-top: 1px solid rgba(234, 239, 255, 0.1);
            display: flex;
            justify-content: center;
        }

        .btn-primary {
            background: #eaefff;
            color: #101010;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .btn-primary:hover {
            background: #ffffff;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(234, 239, 255, 0.3);
        }

        @media (max-width: 768px) {
            .metrics-modal {
                margin: 20px 0;
            }

            .metrics-header {
                padding: 20px;
            }

            .metrics-header h2 {
                font-size: 22px;
            }

            .metrics-content {
                padding: 20px;
            }

            .scores-grid {
                grid-template-columns: 1fr;
            }

            .stats-grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div id="container">
        <button id="interviewButton">
            <span>Begin Interview</span>
        </button>
        <div id="statusText"></div>
        <button id="endButton">End Interview</button>
        <div id="errorMessage" class="error-message"></div>
    </div>

    <script>
        const SYSTEM_PROMPT_BASE = `You are a UPSC Civil Services Personality Test Board Member interviewing candidate Tanya Singh.

CRITICAL RULES - READ CAREFULLY:
1. FIRST RESPONSE ONLY: Say "Good morning, Ms. Singh. Please introduce yourself."
2. AFTER THAT: NEVER greet again. Move straight to substantive questions.
3. Keep ALL responses under 3 sentences (except shared interest discussions)
4. Ask ONE question per response
5. Listen to COMPLETE responses before next question
6. NEVER interrupt mid-sentence

CONVERSATION FLOW:
- Opening ‚Üí Introduction question
- After introduction ‚Üí "Thank you. Why civil services?"
- Then ‚Üí Substantive questions based on DAF
- Never ‚Üí Repeat greetings or pleasantries

YOUR INTERESTS (this session):
{INTERESTS}

When Tanya mentions your interests:
- Show genuine interest (1 sentence)
- Share brief perspective (1 sentence)
- Ask 1 follow-up
- Return to interview

STYLE:
- Conversational, not robotic
- Brief and direct
- Natural pauses
- Professional warmth
- Like talking, not reading

Remember: You're a human having a professional conversation. Be natural, brief, engaged.`;

        let conversationHistory = [];
        let hasGreetedUser = false;
        let isInterviewActive = false;
        let mediaRecorder = null;
        let audioChunks = [];
        let audioContext = null;
        let analyser = null;
        let animationFrameId = null;
        let isProcessing = false;
        let sessionId = null;
        let sessionInterests = [];
        let systemPrompt = '';
        
        // Advanced features
        let silenceDetectionTimer = null;
        let isSpeaking = false;
        let currentAudio = null;
        let interruptionDetected = false;
        let pauseThreshold = 1500; // 1.5 seconds of silence triggers interviewer
        let responseMetrics = [];

        const button = document.getElementById('interviewButton');
        const buttonText = button.querySelector('span');
        const statusText = document.getElementById('statusText');
        const endButton = document.getElementById('endButton');
        const errorMessage = document.getElementById('errorMessage');

        // Show error message
        function showError(message) {
            errorMessage.textContent = message;
            errorMessage.classList.add('visible');
            setTimeout(() => {
                errorMessage.classList.remove('visible');
            }, 5000);
        }

        // Initialize audio context for visualization
        function initAudioContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 256;
            }
        }

        // Start interview
        async function startInterview() {
            isInterviewActive = true;
            conversationHistory = [];
            responseMetrics = [];
            hasGreetedUser = false;
            
            // Initialize session with random interests
            try {
                const sessionResponse = await fetch('/api/session/init', {
                    method: 'POST'
                });
                const sessionData = await sessionResponse.json();
                sessionId = sessionData.sessionId;
                sessionInterests = sessionData.interests;
                
                // Create system prompt with interests
                systemPrompt = SYSTEM_PROMPT_BASE.replace(
                    '{INTERESTS}',
                    `- ${sessionInterests[0]}\n- ${sessionInterests[1]}`
                );
                
                console.log('Session initialized with interests:', sessionInterests);
            } catch (error) {
                console.error('Session init error:', error);
                showError('Failed to initialize session');
                return;
            }
            
            // Fade out text
            buttonText.classList.add('fade-out');
            setTimeout(() => {
                buttonText.style.display = 'none';
            }, 300);

            // Show end button
            endButton.classList.add('visible');

            // Start with greeting from interviewer
            updateStatus('Interviewer is speaking...');
            await speakText("Good morning, Ms. Singh. Please introduce yourself.");
            
            // Start continuous listening with pause detection
            setTimeout(() => startContinuousListening(), 500);
        }

        // End interview and show metrics
        async function endInterview() {
            if (!isInterviewActive) return;
            
            isInterviewActive = false;
            isProcessing = false;
            
            // Stop any ongoing recording
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            }

            // Stop current audio
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }

            // Stop animation
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
            
            // Clear silence detection
            if (silenceDetectionTimer) {
                clearTimeout(silenceDetectionTimer);
            }

            // Show loading state
            updateStatus('Generating your performance report...');
            button.classList.add('speaking');
            
            try {
                // Generate metrics report
                const reportResponse = await fetch('/api/session/report', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sessionId,
                        conversationHistory
                    })
                });
                
                if (reportResponse.ok) {
                    const report = await reportResponse.json();
                    displayMetricsReport(report);
                } else {
                    throw new Error('Failed to generate report');
                }
            } catch (error) {
                console.error('Report generation error:', error);
                showError('Failed to generate performance report');
            }
            
            // Reset UI
            button.classList.remove('active', 'speaking');
            button.style.transform = 'scale(1)';
            buttonText.style.display = 'block';
            buttonText.textContent = 'Begin New Interview';
            buttonText.classList.remove('fade-out');
            button.onclick = () => {
                if (!isInterviewActive) {
                    // Reset and start new
                    conversationHistory = [];
                    responseMetrics = [];
                    sessionId = null;
                    hideMetricsReport();
                    buttonText.textContent = 'Begin Interview';
                    startInterview();
                }
            };
            
            statusText.classList.remove('visible');
            endButton.classList.remove('visible');
        }

        // Update status text
        function updateStatus(text) {
            statusText.textContent = text;
            statusText.classList.add('visible');
        }

        // Text-to-speech using backend
        async function speakText(text) {
            try {
                button.classList.add('speaking');
                
                const response = await fetch('/api/tts', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ text })
                });

                if (!response.ok) {
                    throw new Error('TTS failed');
                }

                const audioBlob = await response.blob();
                const audioUrl = URL.createObjectURL(audioBlob);
                const audio = new Audio(audioUrl);
                
                // Store current audio for interruption detection
                currentAudio = audio;

                return new Promise((resolve, reject) => {
                    audio.onended = () => {
                        button.classList.remove('speaking');
                        URL.revokeObjectURL(audioUrl);
                        currentAudio = null;
                        resolve();
                    };
                    audio.onerror = () => {
                        button.classList.remove('speaking');
                        currentAudio = null;
                        reject(new Error('Audio playback failed'));
                    };
                    
                    // If audio is paused (interrupted), resolve early
                    audio.onpause = () => {
                        if (interruptionDetected) {
                            button.classList.remove('speaking');
                            URL.revokeObjectURL(audioUrl);
                            resolve();
                        }
                    };
                    
                    audio.play().catch(err => {
                        console.error('Audio play error:', err);
                        button.classList.remove('speaking');
                        currentAudio = null;
                        reject(err);
                    });
                });
            } catch (error) {
                console.error('Speech error:', error);
                button.classList.remove('speaking');
                currentAudio = null;
                showError('Speech synthesis error. Please check your connection.');
                throw error;
            }
        }

        // Start continuous listening with pause and interruption detection
        async function startContinuousListening() {
            if (!isInterviewActive || isProcessing) return;

            try {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    } 
                });
                
                initAudioContext();
                const source = audioContext.createMediaStreamSource(stream);
                source.connect(analyser);
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm'
                });
                audioChunks = [];

                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };

                mediaRecorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    
                    if (animationFrameId) {
                        cancelAnimationFrame(animationFrameId);
                    }
                    button.classList.remove('active');
                    button.style.transform = 'scale(1)';

                    if (!isInterviewActive) return;

                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    
                    // Check if this was an interruption
                    if (interruptionDetected) {
                        await handleInterruption(audioBlob);
                    } else {
                        await processUserSpeech(audioBlob);
                    }
                };

                updateStatus('Listening... (Speak naturally, I\'ll know when you\'re done)');
                button.classList.add('active');
                mediaRecorder.start();
                
                // Start silence and volume detection
                detectSpeechAndPauses();
                
                // Allow manual submission by clicking
                button.onclick = () => {
                    if (mediaRecorder && mediaRecorder.state === 'recording') {
                        if (silenceDetectionTimer) {
                            clearTimeout(silenceDetectionTimer);
                        }
                        mediaRecorder.stop();
                        isSpeaking = false;
                        updateStatus('Processing your response...');
                    }
                };

            } catch (error) {
                console.error('Microphone error:', error);
                showError('Microphone access denied. Please allow microphone access and reload.');
                updateStatus('Microphone access required');
            }
        }
        
        // Detect speech activity and pauses
        function detectSpeechAndPauses() {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            const speechThreshold = 30; // Adjust based on testing
            let consecutiveSilenceFrames = 0;
            const silenceFramesNeeded = 120; // ~1.5 seconds at 60fps

            function checkAudioLevel() {
                if (!isInterviewActive || !mediaRecorder || mediaRecorder.state !== 'recording') {
                    return;
                }

                analyser.getByteFrequencyData(dataArray);
                const average = dataArray.reduce((a, b) => a + b) / bufferLength;

                // Detect if user is speaking
                if (average > speechThreshold) {
                    consecutiveSilenceFrames = 0;
                    
                    if (!isSpeaking) {
                        isSpeaking = true;
                        
                        // If interviewer is currently speaking, this is an interruption
                        if (currentAudio && !currentAudio.paused) {
                            console.log('Interruption detected!');
                            interruptionDetected = true;
                            currentAudio.pause();
                            currentAudio = null;
                            button.classList.remove('speaking');
                        }
                    }
                    
                    // Visualize speaking
                    const scale = 1 + (average / 255) * 0.3;
                    button.style.transform = `scale(${scale})`;
                } else {
                    // Silence detected
                    consecutiveSilenceFrames++;
                    button.style.transform = 'scale(1)';
                    
                    // After enough silence, stop recording automatically
                    if (isSpeaking && consecutiveSilenceFrames >= silenceFramesNeeded) {
                        console.log('Pause detected, processing response');
                        isSpeaking = false;
                        if (mediaRecorder && mediaRecorder.state === 'recording') {
                            mediaRecorder.stop();
                        }
                        return;
                    }
                }

                animationFrameId = requestAnimationFrame(checkAudioLevel);
            }

            checkAudioLevel();
        }
        
        // Handle interruption
        async function handleInterruption(audioBlob) {
            console.log('Processing interruption...');
            
            // Track the interruption
            if (sessionId) {
                await fetch('/api/session/track', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        sessionId,
                        interruptionDetected: true,
                        metrics: {}
                    })
                });
            }
            
            interruptionDetected = false;
            
            // Process what user said during interruption
            await processUserSpeech(audioBlob, true);
        }

        // Process user speech
        async function processUserSpeech(audioBlob, wasInterruption = false) {
            if (isProcessing) return;
            isProcessing = true;

            try {
                // Convert audio to text using backend
                const formData = new FormData();
                formData.append('audio', audioBlob, 'audio.webm');

                const transcriptionResponse = await fetch('/api/stt', {
                    method: 'POST',
                    body: formData
                });

                if (!transcriptionResponse.ok) {
                    throw new Error('Transcription failed');
                }

                const transcription = await transcriptionResponse.json();
                const userText = transcription.text;
                const speechMetrics = transcription.metrics;

                if (!userText || userText.trim().length === 0) {
                    updateStatus('No speech detected. Please continue...');
                    isProcessing = false;
                    setTimeout(() => startContinuousListening(), 1000);
                    return;
                }

                console.log('User said:', userText);
                console.log('Speech metrics:', speechMetrics);
                
                // Store metrics
                responseMetrics.push(speechMetrics);
                
                // Track metrics
                if (sessionId) {
                    await fetch('/api/session/track', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            sessionId,
                            metrics: speechMetrics,
                            interruptionDetected: wasInterruption
                        })
                    });
                }

                // Add to conversation history
                conversationHistory.push({
                    role: 'user',
                    content: userText
                });

                // Get interviewer response
                updateStatus('Interviewer is thinking...');
                const interviewerResponse = await getInterviewerResponse();

                console.log('Interviewer responds:', interviewerResponse);

                // Add to conversation history
                conversationHistory.push({
                    role: 'assistant',
                    content: interviewerResponse
                });

                // Speak the response
                updateStatus('Interviewer is speaking...');
                await speakText(interviewerResponse);

                // Continue listening
                isProcessing = false;
                interruptionDetected = false;
                setTimeout(() => startContinuousListening(), 500);

            } catch (error) {
                console.error('Processing error:', error);
                showError('Error processing response. Retrying...');
                isProcessing = false;
                setTimeout(() => startContinuousListening(), 2000);
            }
        }

        // Get response from GPT-4 via backend
        async function getInterviewerResponse() {
            try {
                const systemMessage = hasGreetedUser ? 
            { role: 'system', content: 'You have already greeted the candidate. Continue with substantive interview questions. Do NOT greet again.' } :
            null;
        
        const messages = [
            { role: 'system', content: systemPrompt },
            ...(systemMessage ? [systemMessage] : []),
            ...conversationHistory
        ];
        
        // Mark as greeted after first response
        if (!hasGreetedUser) {
            hasGreetedUser = true;
        }

                const response = await fetch('/api/chat', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ messages })
                });

                if (!response.ok) {
                    throw new Error('Chat API request failed');
                }

                const data = await response.json();
                return data.choices[0].message.content;

            } catch (error) {
                console.error('API error:', error);
                return "I apologize, there was a technical issue. Could you please repeat that?";
            }
        }

        // Display metrics report
        function displayMetricsReport(report) {
            const { analysis, rawMetrics } = report;
            
            // Create metrics overlay
            const overlay = document.createElement('div');
            overlay.id = 'metricsOverlay';
            overlay.innerHTML = `
                <div class="metrics-modal">
                    <div class="metrics-header">
                        <h2>üìä Interview Performance Report</h2>
                        <button class="close-metrics" onclick="hideMetricsReport()">√ó</button>
                    </div>
                    
                    <div class="metrics-content">
                        <div class="metrics-section">
                            <h3>Overall Scores</h3>
                            <div class="scores-grid">
                                <div class="score-card">
                                    <div class="score-label">Content Quality</div>
                                    <div class="score-value">${analysis.scores.content.score}/10</div>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: ${analysis.scores.content.score * 10}%"></div>
                                    </div>
                                </div>
                                <div class="score-card">
                                    <div class="score-label">Communication</div>
                                    <div class="score-value">${analysis.scores.communication.score}/10</div>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: ${analysis.scores.communication.score * 10}%"></div>
                                    </div>
                                </div>
                                <div class="score-card">
                                    <div class="score-label">Confidence</div>
                                    <div class="score-value">${analysis.scores.confidence.score}/10</div>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: ${analysis.scores.confidence.score * 10}%"></div>
                                    </div>
                                </div>
                                <div class="score-card">
                                    <div class="score-label">Knowledge Depth</div>
                                    <div class="score-value">${analysis.scores.knowledge.score}/10</div>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: ${analysis.scores.knowledge.score * 10}%"></div>
                                    </div>
                                </div>
                                <div class="score-card">
                                    <div class="score-label">Interview Etiquette</div>
                                    <div class="score-value">${analysis.scores.etiquette.score}/10</div>
                                    <div class="score-bar">
                                        <div class="score-fill" style="width: ${analysis.scores.etiquette.score * 10}%"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div class="metrics-section">
                            <h3>üìà Quick Stats</h3>
                            <div class="stats-grid">
                                <div class="stat-item">
                                    <span class="stat-label">Total Responses:</span>
                                    <span class="stat-value">${rawMetrics.totalResponses}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Interruptions:</span>
                                    <span class="stat-value ${rawMetrics.interruptions > 0 ? 'warning' : ''}">${rawMetrics.interruptions}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Avg. Filler Words:</span>
                                    <span class="stat-value ${rawMetrics.avgFillers > 3 ? 'warning' : ''}">${rawMetrics.avgFillers}</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-label">Avg. Repetitions:</span>
                                    <span class="stat-value ${rawMetrics.avgRepetitions > 2 ? 'warning' : ''}">${rawMetrics.avgRepetitions}</span>
                                </div>
                            </div>
                        </div>
                        
                        <div class="metrics-section">
                            <h3>üí™ Your Strengths</h3>
                            <ul class="strengths-list">
                                ${analysis.strengths.map(s => `<li class="strength-item">‚úì ${s}</li>`).join('')}
                            </ul>
                        </div>
                        
                        <div class="metrics-section">
                            <h3>üéØ Areas for Improvement</h3>
                            <ul class="improvements-list">
                                ${analysis.improvements.map(i => `<li class="improvement-item">‚Üí ${i}</li>`).join('')}
                            </ul>
                        </div>
                        
                        <div class="metrics-section">
                            <h3>üí¨ Detailed Feedback</h3>
                            ${generateDetailedFeedback(analysis)}
                        </div>
                        
                        <div class="metrics-section">
                            <h3>üìù Overall Impression</h3>
                            <p class="overall-feedback">${analysis.overall}</p>
                        </div>
                    </div>
                    
                    <div class="metrics-footer">
                        <button class="btn-primary" onclick="hideMetricsReport()">Start New Interview</button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(overlay);
            
            // Animate in
            setTimeout(() => {
                overlay.classList.add('visible');
            }, 100);
        }
        
        function generateDetailedFeedback(analysis) {
            let html = '<div class="detailed-feedback">';
            
            for (const [key, data] of Object.entries(analysis.scores)) {
                html += `
                    <div class="feedback-item">
                        <h4>${formatScoreTitle(key)}</h4>
                        <p>${data.feedback}</p>
                    </div>
                `;
            }
            
            if (analysis.detailedNotes) {
                for (const [key, note] of Object.entries(analysis.detailedNotes)) {
                    if (note) {
                        html += `
                            <div class="feedback-item">
                                <h4>${formatScoreTitle(key)}</h4>
                                <p>${note}</p>
                            </div>
                        `;
                    }
                }
            }
            
            html += '</div>';
            return html;
        }
        
        function formatScoreTitle(key) {
            const titles = {
                'content': 'Content Quality',
                'communication': 'Communication Skills',
                'confidence': 'Confidence & Composure',
                'knowledge': 'Knowledge Depth',
                'etiquette': 'Interview Etiquette',
                'fillers': 'Filler Words Usage',
                'interruptions': 'Interruption Handling',
                'repetitions': 'Word Repetitions',
                'pacing': 'Response Pacing'
            };
            return titles[key] || key;
        }
        
        function hideMetricsReport() {
            const overlay = document.getElementById('metricsOverlay');
            if (overlay) {
                overlay.classList.remove('visible');
                setTimeout(() => {
                    overlay.remove();
                }, 300);
            }
        }

        // Event listeners
        button.addEventListener('click', () => {
            if (!isInterviewActive) {
                startInterview();
            }
        });

        endButton.addEventListener('click', endInterview);

        // Ensure audio context is resumed on user interaction
        document.addEventListener('click', () => {
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
        }, { once: true });
    </script>
</body>
</html>